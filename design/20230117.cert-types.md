# Design: Certificate Format Support for Sources / Targets

## Overview

Currently, trust-manager only supports PEM certificates as inputs and PEM trust bundles when
outputting to a target. This is fine most of the time, since most tools seem to have converged on
PEM as the format of choice for consuming and using TLS certificates and trust stores.

However, not all tools support PEM. Notably, Java tends to favor its own format (JKS) for both
consuming TLS certificates and TLS trust stores and some tools might want to provide certificates
in DER or PKCS#12 formats.

This proposal is to add support for alternative types with an eye to extensibility in case we
need to support further types in the future.

## Proposal

On every source field in a `Bundle`, we add a new `format` parameter which allows users to change
the format which trust-manager should expect the source to provide.

On the target field we add a similar field `outputFormat` which would have distinct options but
functionally would be similar.

(Reasoning for input/output being distinct options is given below)

By way of illustration, consider the following `Bundle`:

```yaml
apiVersion: trust.cert-manager.io/v1alpha1
kind: Bundle
metadata:
  name: my-org.com  # The bundle name will also be used for the target
spec:
  # Default to PEM if nothing else specified. Equivalent to "format: { "pem": true }"
  - secret:
      name: "secret-1"
      key: "thing.pem"

  # DER certificates - can only contain one cert. Since DER is binary it would be expected that the
  # certificate is base64 encoded in the Secret.
  - secret:
      name: "secret-2"
      key: "thing.der"
    format:
      der: true

  # JKS trust store. Can contain multiple certs. Base64 encoded since the format is binary.
  # May need a password (which is likely security theater but is still a problem we'd need to
  # solve in practice)
  - secret:
      name: "secret-2"
      key: "thing.der"
    format:
      jks:
        passwordPlaintext: "theater"

  # As above, JKS trust store. Uses a password in a `Secret` in the trust namespace.
  - secret:
      name: "secret-2"
      key: "thing.der"
    format:
      jks:
        passwordSecretRef:
          name: "my-secret-password"
          key: "theater"

  target:
    configMap:
      key: "root-certs.pem"
    outputFormat:
      jks:
        passwordPlaintext: "theater"
        # could also have a secret ref for the password
```

### Initial Supported Formats

For inputs: add DER and JKS.

For outputs: add JKS.

DER is not an appropriate format for storing multiple certificates. Anecdotally most tools don't
expect multiple concatenated DER certificates, and the format doesn't provide any kind of container
or for any separation of different certificate blocks. As such, DER is a fine input format
(and very simple to implement) but is left out for output formats pending a specific need for it.

JKS, on the other hand, makes a lot of sense both as an input format but also as an output format.
JKS will require the use of a library for reading and writing, and the complexity there is likely
to be in handling passwords which will be required on inputs and potentially on outputs. Although
these passwords are likely to provide absolutely no practical security benefits, they're often
required by either policy or process.

PKCS#12 encoded certificates might be a source/target for the future if requested, but seem less
likely to be useful since they mostly encode certificates + private keys, rather than trust
stores. As such, PKCS#12 is left out here to reduce the scope of this proposal, but we should
implement this proposal with PKCS#12 in mind being sure that it's easy to add it later if required.

### Internal Handling of Certificates

Trying to specify code which converts any format of certificate directly to any other format is likely
to be frustrating and difficult to debug. We must be sure that when we handle certificates internally,
we always convert inputs to the same intermediate representation, and then define conversions from
that intermediate representation to specific output formats.

The intermediate format is likely to either be PEM or else decoded Golang structs (`x509.Certificate`).

## Potential Issues

### JKS Library

We've had issues in the cert-manager project with the JKS library we chose there. We might want to
spend time to make sure we pick the right library for this task with that in mind.

### JKS Passwords

Adding JKS introduces a requirement to handle secrets which are not related to certificates - namely,
JKS passwords, which as mentioned above are likely to be unavoidable. If we only support having
these passwords in plaintext in resource YAML, it's simple enough to support them since we add no
extra dependencies on external resources.

For targets, plaintext 'passwords' in the resource YAML seem likely to be acceptable. However, at
least for sources, it's easy to anticipate a user needing to read a password from a Kubernetes `Secret`.

Adding the ability to load from `Secret`s introduces new potential failure modes; `SecretNotFound` and
`InvalidSecret` are both predictable, but we'd also have to deal with updates to password `Secrets` and
define how rotating a password for a JKS source would work in practice. This isn't generally achievable
safely without adding the ability to read multiple passwords from the same Secret and then try all
of them.

## Further Reading

It might be useful to read the [relevant RFC](https://www.rfc-editor.org/rfc/rfc7468) which
specifies the PEM format for certificates, as a point of interest.
